using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.IO;
using System.Reflection;
using System.Text.RegularExpressions;

namespace Configure {
    /// <summary>
    /// Implements installation and uninstallation of the FFmpegThumbnailProvider component
    /// as well as some other configuration options.
    /// </summary>
    public static class Config {
        static readonly string[] Extensions = {
            "3g2", "3gp", "asf", "avi", "flv", "m4v", "mkv", "mov", "mp4", "m4p", "mpg",
            "mp2", "mpe", "mpeg", "mpv", "m2v", "ts", "ogv", "vob", "webm", "wmv"
        };

        [DllImport("Shell32.dll")]
        static extern int SHChangeNotify(int eventId, uint flags, IntPtr dwItem1, IntPtr dwItem2);

        /// <summary>
        /// The CLSID of our FFmpegThumbnailProvider.
        /// </summary>
        const string Clsid = "{8D60D8ED-AC78-444B-9FC8-DDE8240A2A9B}";

        /// <summary>
        /// The registration path of our IThumbnailProvider COM component.
        /// </summary>
        const string RegPath = @"HKEY_CURRENT_USER\Software\Classes\CLSID\" + Clsid;

        /// <summary>
        /// The name of the dll that implements the COM class.
        /// </summary>
        const string Dll = "FFmpegThumbnailProvider.dll";

        /// <summary>
        /// Installs the FFmpegThumbnailProvider with Windows Explorer.
        /// </summary>
        public static void Install() {
            // 1. Extract the embedded files into our application's AppData directory.
            ExtractResources();
            // 2. Invoke regsvr32.exe
            var ret = InvokeRegSvr32(true);
            if (ret != 0)
                throw new Exception($"Registration of {Dll} failed with error-code {ret}.");
            // 3. Restart explorer.exe
            RestartExplorer();
        }

        /// <summary>
        /// Uninstalls the FFmpegThumbnailProvider.
        /// </summary>
        public static void Uninstall() {
            // 1. Invoke regsvr32.exe
            var ret = InvokeRegSvr32(false);
            if (ret != 0)
                throw new Exception($"Unregistration of {Dll} failed with error-code {ret}.");
            // 2. Clear/Restore any file-type associations.

            // 3. Restart explorer.exe
            RestartExplorer();
            // 4. Remove Application Directory.
            Directory.Delete(GetAppDirectory(), true);
        }

        /// <summary>
        /// Clears the Windows Thumbnail Cache so that thumbnails for file-types will be
        /// regenerated by their respective IThumbnailProvider.
        /// </summary>
        public static void ClearThumbnailCache() {
            const int SHCNE_ASSOCCHANGED = 0x08000000;
            const int SHCNF_FLUSH = 0x1000;
            // 1. Invalidate Windows Thumbnail Cache.
            SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_FLUSH, IntPtr.Zero, IntPtr.Zero);
            // 2. Restart explorer.exe
            RestartExplorer();
        }

        /// <summary>
        /// Returns the current installation path of our IThumbnailProvider component.
        /// </summary>
        /// <returns>
        /// The installation path of the FFmpegThumbnailProvider or null if it has not been
        /// installed/registered.
        /// </returns>
        public static string GetInstallationPath() {
            var value = Registry.GetValue(RegPath + @"\InProcServer32", null, null);
            if (value == null)
                return null;
            return Path.GetDirectoryName(value.ToString());
        }

        public static int GetThumbnailTimestamp() {
            var val = Registry.GetValue(RegPath, "ThumbnailTimestamp", -1);
            if (val == null)
                return -1;
            return (int)val;
        }

        public static void SetThumbnailTimestamp(int value) {
            Registry.SetValue(RegPath, "ThumbnailTimestamp", value);
            // Set stuff in registry.
        }

        public static IDictionary<string, bool> GetFileAssociations() {
            var ret = new Dictionary<string, bool>();
            foreach (var ext in Extensions)
                ret[ext] = IsAssociated(ext);
            return ret;
        }

        public static void SetFileAssociations(IDictionary<string, bool> dict) {
            foreach (var p in dict) {
                if (IsAssociated(p.Key)) {
                    if (!p.Value) {
                        // Restore old values if any.
                    }
                } else {
                    if (p.Value) {
                        // Save old values if any.
                        // Associate.
                    }
                }
            }
        }

        /// <summary>
        /// Invokes the 'regsvr32' utility and returns it's exit-code.
        /// </summary>
        /// <param name="install">
        /// true to install the DLL, or false to uninstall it.
        /// </param>
        /// <returns>
        /// The exit-code returned by the 'regsvr32' process.
        /// </returns>
        static int InvokeRegSvr32(bool install) {
            using (var p = new Process()) {
                var path = Path.Combine(
                    GetAppDirectory(), Dll
                );
                p.StartInfo.FileName = "regsvr32.exe";
                p.StartInfo.Arguments = install ? $"/s {path}" : $"/s /u {path}";
                p.StartInfo.UseShellExecute = false;
                p.Start();
                p.WaitForExit();
                return p.ExitCode;
            }
        }

        /// <summary>
        /// Restarts the Windows explorer process.
        /// </summary>
        static void RestartExplorer() {
            Process.GetProcessesByName("explorer");
            foreach (var p in Process.GetProcessesByName("explorer"))
                p.Kill();
//            Process.Start("explorer.exe");
        }

        /// <summary>
        /// Gets whether the specified file extension is associated to our
        /// IThumbnailProvider.
        /// </summary>
        /// <param name="extension">
        /// The file extension.
        /// </param>
        /// <returns>
        /// true if the file extension is associated to the FFmpegThumbnailProvider; otherwise
        /// false.
        /// </returns>
        static bool IsAssociated(string extension) {
            // {E357FCCD-A995-4576-B01F-234630154E96} is the CLSID for
            // IThumbnailProvider implementations.
            var path = $@"HKEY_CURRENT_USER\Software\Classes\.{extension}\ShellEx\" +
                "{e357fccd-a995-4576-b01f-234630154e96}";
            var value = Registry.GetValue(path, null, null);
            return Clsid.Equals(value?.ToString(),
                StringComparison.InvariantCultureIgnoreCase);
        }

        /// <summary>
        /// Returns the application directory where we keep our files.
        /// </summary>
        /// <returns>
        /// The application directory under appData.
        /// </returns>
        static string GetAppDirectory() {
            return Path.Combine(
                Environment.GetFolderPath(
                    Environment.SpecialFolder.LocalApplicationData
                ),
                "FFmpegThumbnailProvider"
            );
        }

        /// <summary>
        /// Extracts the embedded FFmpeg binaries and our FFmpegThumbnailHandler DLL into
        /// our application directory.
        /// </summary>
        static void ExtractResources() {
            var path = GetAppDirectory();
            Directory.CreateDirectory(path);
            var asm = Assembly.GetExecutingAssembly();
            foreach (var n in asm.GetManifestResourceNames()) {
                var m = Regex.Match(n, $@"^{nameof(Configure)}\.Resources\.(.+)");
                if (!m.Success)
                    continue;
                var filename = m.Groups[1].Value;
                var dstPath = Path.Combine(path, filename);
                using (var fs = File.Create(dstPath)) {
                    using (var s = asm.GetManifestResourceStream(n))
                        s.CopyTo(fs);
                }
            }
        }
    }
}
